generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

enum Role {
  superadmin
  admin
  generaltrainer
  personaltrainer
  member
  housekeeping
  receptionist
}

// Staff Role model for dynamic role management
model StaffRole {
  id          Int      @id @default(autoincrement())
  name        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  staff Staff[]
}

enum BranchStatus {
  ACTIVE
  INACTIVE
  MAINTENANCE
}

// User model for authentication and role management
model User {
  id        Int      @id @default(autoincrement())
  firstName String
  lastName  String
  email     String   @unique
  password  String // Hashed password
  role      Role     @default(member)
  branchId  Int?
  branch    Branch?  @relation(fields: [branchId], references: [id], map: "User_branchId_fkey")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Extended member fields
  memberId         String?   @unique // Unique member identifier
  middleName       String?
  gender           String?
  dob              DateTime?
  phone            String?
  address          String?
  city             String?
  state            String?
  profile_photo    String?
  joiningDate      DateTime?
  expireDate       DateTime?
  memberType       String?   @default("Member") // Member, Staff, etc.
  memberStatus     String?   @default("Active") // Active, Inactive, Suspended
  membershipStatus String?   @default("Activate") // Activate, Activated, Expired
  planId           Int? // Associated membership plan
  plan             Plan?     @relation("MemberPlan", fields: [planId], references: [id])

  // Physical measurements (optional)
  weight Float?
  height Float?
  chest  Float?
  waist  Float?
  thigh  Float?
  arms   Float?
  fat    Float?

  // Login credentials for members (optional)
  username          String?
  loginEnabled      Boolean   @default(false)

  // Audit fields
  createdBy         String? // Role of user who created this member (superadmin, admin, receptionist)

  // Relations
  adminBranches       Branch[]            @relation("BranchAdmin", map: "Branch_adminId_fkey")
  createdBranches     Branch[]            @relation("BranchCreator", map: "Branch_createdById_fkey")
  managedMembers      User[]              @relation("StaffMembers")
  managedByStaff      User?               @relation("StaffMembers", fields: [managedByStaffId], references: [id])
  managedByStaffId    Int?
  managedStaff        Staff[]             @relation("StaffManager", map: "Staff_userId_fkey")
  createdStaff        Staff[]             @relation("StaffCreator", map: "Staff_createdById_fkey")
  scannedQRs          QRCheck[]           @relation("QRCheckMember", map: "QRCheck_memberId_fkey")
  trainerClasses      ClassSchedule[]     @relation("ClassTrainer", map: "ClassSchedule_trainer_id_fkey")
  adminClasses        ClassSchedule[]     @relation("ClassAdmin", map: "ClassSchedule_adminId_fkey")
  bookings            PlanBooking[]
  memberPlans         MemberPlan[]
  createdPlans        Plan[]              @relation("PlanAdmin", map: "Plan_adminId_fkey")
  createdBranchPlans  BranchPlan[]        @relation("BranchPlanCreatedBy", map: "BranchPlan_createdById_fkey")
  branchPlanBookings  BranchPlanBooking[]
  memberBranchPlans   MemberBranchPlan[]
  scannedQRsAsScanner QRCheck[]           @relation("QRCheckScanner", map: "QRCheck_scannedBy_fkey")
  groupId             Int?
  group               Group?              @relation("GroupMembers", fields: [groupId], references: [id])
}

// Branch model for gym branches
model Branch {
  id           Int          @id @default(autoincrement())
  name         String
  code         String       @unique
  address      String
  phone        String?
  email        String?
  status       BranchStatus @default(INACTIVE)
  hours        Json
  branch_image String?
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt

  // Relations
  adminId     Int
  admin       User            @relation("BranchAdmin", fields: [adminId], references: [id])
  createdById Int?
  createdBy   User?           @relation("BranchCreator", fields: [createdById], references: [id])
  users       User[]
  staff       Staff[]
  plans       Plan[]
  branchPlans BranchPlan[]
  qrChecks    QRCheck[]
  attendances Attendance[]
  classes     ClassSchedule[]
  groups      Group[]
}

// Staff model for staff management
model Staff {
  id                      Int       @id @default(autoincrement())
  userId                  Int       @unique
  user                    User      @relation("StaffManager", fields: [userId], references: [id], map: "Staff_userId_fkey")
  branchId                Int
  branch                  Branch    @relation(fields: [branchId], references: [id], map: "Staff_branchId_fkey")
  roleId                  Int
  role                    StaffRole @relation(fields: [roleId], references: [id], map: "Staff_roleId_fkey")
  staff_id                String    @unique
  gender                  String?
  dob                     DateTime?
  phone                   String?
  profile_photo           String?
  status                  String    @default("Active")
  join_date               DateTime
  exit_date               DateTime?
  salary_type             String? // "Fixed" or "Hourly"
  hourly_rate             Float?
  fixed_salary            Float?
  commission_rate_percent Float     @default(0)
  login_enabled           Boolean   @default(false)
  username                String?
  password                String? // Hashed password for staff login
  createdById             Int? // ID of the user who created this staff record
  createdBy               User?     @relation("StaffCreator", fields: [createdById], references: [id], map: "Staff_createdById_fkey")
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt

  // Relations
  qrChecks    QRCheck[]    @relation("QRCheckStaff")
  attendances Attendance[] @relation("AttendanceStaff")
}

// Plan model for gym plans (legacy, global plans)
model Plan {
  id         Int      @id @default(autoincrement())
  name       String
  type       String // "group" | "personal"
  sessions   Int
  validity   Int // days
  priceCents Int // store price in cents/paise
  currency   String   @default("INR")
  active     Boolean  @default(true)
  adminId    Int // who created
  branchId   Int? // optional multi-branch
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  admin       User          @relation("PlanAdmin", fields: [adminId], references: [id], map: "Plan_adminId_fkey")
  branch      Branch?       @relation(fields: [branchId], references: [id], map: "Plan_branchId_fkey")
  bookings    PlanBooking[]
  memberPlans MemberPlan[]
  members     User[]        @relation("MemberPlan") // Members associated with this plan
}

// BranchPlan model for branch-specific plans
model BranchPlan {
  id          Int      @id @default(autoincrement())
  name        String
  type        String // "group" | "personal"
  sessions    Int
  validity    Int // days
  priceCents  Int // store price in cents/paise
  currency    String   @default("INR")
  active      Boolean  @default(true)
  branchId    Int // required branch association
  createdById Int // who created
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  branch      Branch              @relation(fields: [branchId], references: [id], map: "BranchPlan_branchId_fkey")
  createdBy   User                @relation("BranchPlanCreatedBy", fields: [createdById], references: [id], map: "BranchPlan_createdById_fkey")
  bookings    BranchPlanBooking[]
  memberPlans MemberBranchPlan[]
}

// PlanBooking model for member booking requests
model PlanBooking {
  id           Int      @id @default(autoincrement())
  memberId     Int
  planId       Int
  requestedAt  DateTime @default(now())
  status       String   @default("pending") // pending/approved/rejected
  sessionsUsed Int      @default(0)
  note         String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  member User @relation(fields: [memberId], references: [id])
  plan   Plan @relation(fields: [planId], references: [id])
}

// MemberPlan model for active member subscriptions (legacy)
model MemberPlan {
  id                Int      @id @default(autoincrement())
  memberId          Int
  planId            Int
  startDate         DateTime
  expiryDate        DateTime
  remainingSessions Int
  createdAt         DateTime @default(now())

  member User @relation(fields: [memberId], references: [id])
  plan   Plan @relation(fields: [planId], references: [id])
}

// BranchPlanBooking model for member booking requests for branch plans
model BranchPlanBooking {
  id           Int      @id @default(autoincrement())
  memberId     Int
  branchPlanId Int
  requestedAt  DateTime @default(now())
  status       String   @default("pending") // pending/approved/rejected
  sessionsUsed Int      @default(0)
  note         String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  member     User       @relation(fields: [memberId], references: [id])
  branchPlan BranchPlan @relation(fields: [branchPlanId], references: [id])
}

// MemberBranchPlan model for active member subscriptions to branch plans
model MemberBranchPlan {
  id                Int      @id @default(autoincrement())
  memberId          Int
  branchPlanId      Int
  startDate         DateTime
  expiryDate        DateTime
  remainingSessions Int
  createdAt         DateTime @default(now())

  member     User       @relation(fields: [memberId], references: [id])
  branchPlan BranchPlan @relation(fields: [branchPlanId], references: [id])
}

// AuditLog model for logging actions
model AuditLog {
  id        Int      @id @default(autoincrement())
  actorId   Int?
  action    String // e.g. "plan.create", "plan.update", "booking.approve"
  payload   Json?
  branchId  Int?
  createdAt DateTime @default(now())
}

// QRCheck model for quick log of scanned QR entries
model QRCheck {
  id        Int       @id @default(autoincrement())
  memberId  Int?
  staffId   Int?
  branchId  Int
  nonce     String    @unique
  issuedAt  DateTime
  expiresAt DateTime
  scannedAt DateTime?
  action    String // 'checkin' or 'checkout'
  status    String    @default("valid") // valid, expired, invalid, used
  scannedBy Int? // userId of who scanned
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relations
  member  User?  @relation("QRCheckMember", fields: [memberId], references: [id], map: "QRCheck_memberId_fkey")
  staff   Staff? @relation("QRCheckStaff", fields: [staffId], references: [id], map: "QRCheck_staffId_fkey")
  branch  Branch @relation(fields: [branchId], references: [id], map: "QRCheck_branchId_fkey")
  scanner User?  @relation("QRCheckScanner", fields: [scannedBy], references: [id], map: "QRCheck_scannedBy_fkey")
}

// Attendance model for official attendance records
model Attendance {
  id           Int       @id @default(autoincrement())
  memberId     Int?
  staffId      Int?
  branchId     Int
  date         DateTime // date of attendance
  checkInTime  DateTime?
  checkOutTime DateTime?
  totalHours   Float?
  status       String    @default("active") // active, completed
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  staff  Staff? @relation("AttendanceStaff", fields: [staffId], references: [id])
  branch Branch @relation(fields: [branchId], references: [id])
}

// ClassSchedule model for gym class management
model ClassSchedule {
  id           Int      @id @default(autoincrement())
  class_name   String
  trainer_id   Int
  date         DateTime
  time         String
  schedule_day Json // Array of days ["Monday", "Wednesday"]
  total_sheets Int      @default(20)
  status       String   @default("Active")
  branchId     Int
  adminId      Int
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  trainer User   @relation("ClassTrainer", fields: [trainer_id], references: [id])
  admin   User   @relation("ClassAdmin", fields: [adminId], references: [id])
  branch  Branch @relation(fields: [branchId], references: [id])
}

// Group model for gym groups
model Group {
  id        Int      @id @default(autoincrement())
  name      String
  photo     String?
  branchId  Int
  branch    Branch   @relation(fields: [branchId], references: [id])
  members   User[]   @relation("GroupMembers")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
